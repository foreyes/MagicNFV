1. 完成模型: Packet, State, Condition, ValueSource
2. States 包含目前已经满足的 Conditions

重点: 在优化阶段，如果试图读取一个 "unknown" 的字段，抛出一个错误。外部通过这个错误得知运算结果不可预知


弄一个专门的 "结构优化"，主的优化流程每一步结束后都加一个 "结构优化"

主要流程:

- 拆分路径
- 分支整理
- 硬件前提
- 软件调序
- 树上 DP

辅助流程:

- 结构优化
- 判断冲突
- 软件调序算法

结构优化:

- 状态推导
- 分支条件化简
- 表达式化简
- 分支 Discard 消除


（可选）跨两格 push down 或 pull up


1-2. 完成代价模型
2. 算法框架（怎么处理服务链）
3. 拆分树结构
4. 路径整合
5. 判断是否冲突，建立冲突图G
6. 硬件分支前提（可能可以合并到4）
7. 软件顺序调整（凑成 k 簇，可以考虑对于 k = 1, 2 单独考虑）
8. 树上DP


Tips:
对于一个模块化的软件 NF，可以假定它不会访问其他 NF 所写的 "包私有状态"


----------------------- 在 "will_write" 想办法把 "包字段" "全局状态" "包私有状态" 区分一下


路径整合(part1):
1. DFS 一条路径，保存到每一个点时的状态，经过一个点相应地更
新一下状态
2. 分支时，对分支条件进行 eliminate
3. 若分支条件被消除为 False, 删除该分支
   若分支条件被消除为 True，将其作为 else，删除后续分支
   若消除完的分类器只剩下一条分支，或全部分支都是 Discard，删除该分类器
4. 分支完后，在当前状态里加上分支的条件
5. 若遍历到 Discard，直到上一个分支点前的 "不写全局状态的" NF 可以去掉
6.（可选）记录每个字段读写记录，若某次写 "包私有状态" 之后不会再读它，该写操作可消除
7.（可选）路径上读写整合。 y = x + 1; y = 2; 变成 y = 2;


（可选）分析 "包私有状态" 的有效域，在有效域之前的结点不可能读取该状态。


判断是否冲突:
1. 先整一个严格一点的(把复杂的情况都当作冲突)


硬件分支前提:
1. 自底向上提，遇到另一个硬件分支就合并


路径整合(part2)（可选）
注意: 该步骤需要在软件功能调整前后都做一次
1. 对于每一条路径，进行逻辑读写的消除及整合
2.（可选）记录每个字段读写记录，若某次写 "包私有状态" 之后不会再读它，该写操作可消除

软件顺序调整:


树上 DP:
1. 基于代价，先完成代价模型